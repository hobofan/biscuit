var searchIndex = {};
searchIndex["biscuit"] = {"doc":"![Build Status](https://travis-ci.org/lawliet89/biscuit.svg) ![Crates.io](https://img.shields.io/crates/v/biscuit.svg) ![Repository](https://img.shields.io/github/tag/lawliet89/biscuit.svg) ![Documentation](https://docs.rs/biscuit/badge.svg)","items":[[3,"Url","biscuit","A parsed URL record.",null,null],[4,"ParseError","","Errors that can occur during parsing.",null,null],[13,"EmptyHost","","",0,null],[13,"IdnaError","","",0,null],[13,"InvalidPort","","",0,null],[13,"InvalidIpv4Address","","",0,null],[13,"InvalidIpv6Address","","",0,null],[13,"InvalidDomainCharacter","","",0,null],[13,"RelativeUrlWithoutBase","","",0,null],[13,"RelativeUrlWithCannotBeABaseBase","","",0,null],[13,"SetHostOnCannotBeABaseUrl","","",0,null],[13,"Overflow","","",0,null],[3,"Empty","","An empty struct that derives Serialize and Deserialize. Can be used, for example, in places where a type for custom values (such as private claims in a `ClaimsSet`) is required but you have nothing to implement.",null,null],[3,"Base64Url","","A newtype wrapper around a string to indicate it's base64 URL encoded",null,null],[3,"Compact","","A collection of `CompactPart`s that have been converted to `Base64Url`",null,null],[12,"parts","","Parts of the compact representation",1,null],[3,"Timestamp","","Wrapper around `DateTime<UTC>` to allow us to do custom de(serialization)",null,null],[3,"RegisteredClaims","","Registered claims defined by RFC7519#4.1",null,null],[12,"issuer","","Token issuer. Serialized to `iss`.",2,null],[12,"subject","","Subject where the JWT is referring to. Serialized to `sub`",2,null],[12,"audience","","Audience intended for the JWT. Serialized to `aud`",2,null],[12,"expiry","","Expiration time in seconds since Unix Epoch. Serialized to `exp`",2,null],[12,"not_before","","Not before time in seconds since Unix Epoch. Serialized to `nbf`",2,null],[12,"issued_at","","Issued at Time in seconds since Unix Epoch. Serialized to `iat`",2,null],[12,"id","","Application specific JWT ID. Serialized to `jti`",2,null],[3,"TemporalValidationOptions","","Options for claims time validation By default, no temporal claims (namely `iat`, `exp`, `nbf`) are required, and they will pass validation if they are missing. Should any temporal claims be needed, set the appropriate fields. To deal with clock drifts, you might want to provide an `epsilon` error margin in the form of a `std::time::Duration` to allow time comparisons to fall within the margin.",null,null],[12,"issued_at_required","","Whether the `iat` or `Issued At` field is required",3,null],[12,"not_before_required","","Whether the `nbf` or `Not Before` field is required",3,null],[12,"expiry_required","","Whether the `exp` or `Expiry` field is required",3,null],[12,"epsilon","","Allow for some clock drifts, limited to this duration during temporal validation",3,null],[12,"now","","Specify a time to use in temporal validation instead of `Now`.",3,null],[3,"ClaimsSet","","A collection of claims, both registered and your custom private claims.",null,null],[12,"registered","","Registered claims defined by the RFC",4,null],[12,"private","","Application specific claims",4,null],[4,"SingleOrMultiple","","Represents a choice between a single value or multiple values. This value is serialized by serde untagged.",null,null],[13,"Single","","One single value",5,null],[13,"Multiple","","Multiple values",5,null],[4,"StringOrUri","","Represents a choice between a URI or an arbitrary string. Both variants will serialize to a string. According to RFC 7519, any string containing the \":\" character will be deserialized as a URL. Any invalid URLs will be treated as a deserialization failure. The URL is parsed according to the URL Standard which supersedes RFC 3986 as required in the JWT RFC.",null,null],[13,"String","","A generic string",6,null],[13,"Uri","","A parsed URI",6,null],[0,"errors","","Errors returned will be converted to one of the structs in this module.",null,null],[4,"Error","biscuit::errors","All the errors we can encounter while signing/verifying tokens and a couple of custom one for when the token we are trying to verify is invalid",null,null],[13,"GenericError","","A generic error which is described by the contained string",7,null],[13,"ValidationError","","Error returned from failed token validation",7,null],[13,"JsonError","","Error during the serialization or deserialization of tokens",7,null],[13,"DecodeBase64","","Error during base64 encoding or decoding",7,null],[13,"Utf8","","Error when decoding bytes to UTF8 string",7,null],[13,"IOError","","Errors related to IO",7,null],[13,"UriParseError","","Errors related to URI parsing",7,null],[13,"WrongKeyType","","Wrong key type was provided for the cryptographic operation",7,null],[12,"expected","biscuit::errors::Error","Expected type of key",7,null],[12,"actual","","Actual type of key",7,null],[13,"UnspecifiedCryptographicError","biscuit::errors","An unknown cryptographic error",7,null],[13,"UnsupportedOperation","","An unsupported or invalid operation",7,null],[4,"ValidationError","","Errors from validating tokens",null,null],[13,"InvalidToken","","Token is invalid in structure or form",8,null],[13,"InvalidSignature","","Token has an invalid signature",8,null],[13,"WrongAlgorithmHeader","","Token provided was signed or encrypted with an unexpected algorithm",8,null],[13,"MissingRequired","","A field required is missing from the token",8,null],[13,"TemporalError","","The token has invalid temporal field values",8,null],[13,"PartsLengthError","","The number of compact parts is incorrect",8,null],[12,"expected","biscuit::errors::ValidationError","Expected number of parts",8,null],[12,"actual","","Actual number of parts",8,null],[11,"fmt","biscuit::errors","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",7,{"inputs":[{"name":"string"}],"output":{"name":"error"}}],[11,"from","","",7,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","",7,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","",7,{"inputs":[{"name":"utf8error"}],"output":{"name":"error"}}],[11,"from","","",7,{"inputs":[{"name":"validationerror"}],"output":{"name":"error"}}],[11,"from","","",7,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","",7,{"inputs":[{"name":"parseerror"}],"output":{"name":"error"}}],[11,"from","","",7,{"inputs":[{"name":"unspecified"}],"output":{"name":"self"}}],[11,"from","","",7,{"inputs":[{"name":"fromutf8error"}],"output":{"name":"self"}}],[11,"description","","",7,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",7,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",8,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",8,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"jwa","biscuit","JSON Web Algorithms",null,null],[3,"EncryptionResult","biscuit::jwa","The result returned from an encryption operation",null,null],[12,"nonce","","The initialization vector, or nonce used in the encryption",9,null],[12,"encrypted","","The encrypted payload",9,null],[12,"tag","","The authentication tag",9,null],[12,"additional_data","","Additional authenticated data that is integrity protected but not encrypted",9,null],[4,"Algorithm","","Algorithms described by RFC 7518. This enum is serialized `untagged`.",null,null],[13,"Signature","","Algorithms meant for Digital signature or MACs See RFC7518#3",10,null],[13,"KeyManagement","","Algorithms meant for key management. The algorithms are either meant to encrypt a content encryption key or determine the content encryption key. See RFC7518#4",10,null],[13,"ContentEncryption","","Algorithms meant for content encryption. See RFC7518#5",10,null],[4,"SignatureAlgorithm","","The algorithms supported for digital signature and MACs, defined by RFC7518#3.",null,null],[13,"None","","No encryption/signature is included for the JWT. During verification, the signature _MUST BE_ empty or verification  will fail.",11,null],[13,"HS256","","HMAC using SHA-256",11,null],[13,"HS384","","HMAC using SHA-384",11,null],[13,"HS512","","HMAC using SHA-512",11,null],[13,"RS256","","RSASSA-PKCS1-v1_5 using SHA-256",11,null],[13,"RS384","","RSASSA-PKCS1-v1_5 using SHA-384",11,null],[13,"RS512","","RSASSA-PKCS1-v1_5 using SHA-512",11,null],[13,"ES256","","ECDSA using P-256 and SHA-256",11,null],[13,"ES384","","ECDSA using P-384 and SHA-384",11,null],[13,"ES512","","ECDSA using P-521 and SHA-512 -- This variant is unsupported and will probably never be.",11,null],[13,"PS256","","RSASSA-PSS using SHA-256 and MGF1 with SHA-256. The size of the salt value is the same size as the hash function output.",11,null],[13,"PS384","","RSASSA-PSS using SHA-384 and MGF1 with SHA-384 The size of the salt value is the same size as the hash function output.",11,null],[13,"PS512","","RSASSA-PSS using SHA-512 and MGF1 with SHA-512 The size of the salt value is the same size as the hash function output.",11,null],[4,"KeyManagementAlgorithm","","Algorithms for key management as defined in RFC7518#4",null,null],[13,"RSA1_5","","RSAES-PKCS1-v1_5",12,null],[13,"RSA_OAEP","","RSAES OAEP using default parameters",12,null],[13,"RSA_OAEP_256","","RSAES OAEP using SHA-256 and MGF1 with SHA-256",12,null],[13,"A128KW","","AES Key Wrap using 128-bit key. _Unsupported_",12,null],[13,"A192KW","","AES Key Wrap using 192-bit key. _Unsupported_. This is not supported by `ring`.",12,null],[13,"A256KW","","AES Key Wrap using 256-bit key. _Unsupported_",12,null],[13,"DirectSymmetricKey","","Direct use of a shared symmetric key",12,null],[13,"ECDH_ES","","ECDH-ES using Concat KDF",12,null],[13,"ECDH_ES_A128KW","","ECDH-ES using Concat KDF and \"A128KW\" wrapping",12,null],[13,"ECDH_ES_A192KW","","ECDH-ES using Concat KDF and \"A192KW\" wrapping",12,null],[13,"ECDH_ES_A256KW","","ECDH-ES using Concat KDF and \"A256KW\" wrapping",12,null],[13,"A128GCMKW","","Key wrapping with AES GCM using 128-bit key alg",12,null],[13,"A192GCMKW","","Key wrapping with AES GCM using 192-bit key alg. This is not supported by `ring`.",12,null],[13,"A256GCMKW","","Key wrapping with AES GCM using 256-bit key alg",12,null],[13,"PBES2_HS256_A128KW","","PBES2 with HMAC SHA-256 and \"A128KW\" wrapping",12,null],[13,"PBES2_HS384_A192KW","","PBES2 with HMAC SHA-384 and \"A192KW\" wrapping",12,null],[13,"PBES2_HS512_A256KW","","PBES2 with HMAC SHA-512 and \"A256KW\" wrapping",12,null],[4,"KeyManagementAlgorithmType","","Describes the type of operations that the key management algorithm supports with respect to a Content Encryption Key (CEK)",null,null],[13,"SymmetricKeyWrapping","","Wraps a randomly generated CEK using a symmetric encryption algorithm",13,null],[13,"AsymmetricKeyEncryption","","Encrypt a randomly generated CEK using an asymmetric encryption algorithm,",13,null],[13,"DirectKeyAgreement","","A key agreement algorithm to pick a CEK",13,null],[13,"KeyAgreementWithKeyWrapping","","A key agreement algorithm used to pick a symmetric CEK and wrap the CEK with a symmetric encryption algorithm",13,null],[13,"DirectEncryption","","A user defined symmetric shared key is the CEK",13,null],[4,"ContentEncryptionAlgorithm","","Algorithms meant for content encryption. See RFC7518#5",null,null],[13,"A128CBC_HS256","","AES_128_CBC_HMAC_SHA_256 authenticated encryption algorithm enc",14,null],[13,"A192CBC_HS384","","AES_192_CBC_HMAC_SHA_384 authenticated encryption algorithm enc",14,null],[13,"A256CBC_HS512","","AES_256_CBC_HMAC_SHA_512 authenticated encryption algorithm enc",14,null],[13,"A128GCM","","AES GCM using 128-bit key",14,null],[13,"A192GCM","","AES GCM using 192-bit key This is not supported by `ring`.",14,null],[13,"A256GCM","","AES GCM using 256-bit key",14,null],[5,"rng","","Return a psuedo random number generator",null,{"inputs":[],"output":{"name":"systemrandom"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"algorithm"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"self"},{"name":"algorithm"}],"output":{"name":"bool"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"algorithm"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",11,{"inputs":[{"name":"self"},{"name":"signaturealgorithm"}],"output":{"name":"bool"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"signaturealgorithm"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",12,{"inputs":[{"name":"self"},{"name":"keymanagementalgorithm"}],"output":{"name":"bool"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"keymanagementalgorithm"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",13,{"inputs":[{"name":"self"},{"name":"keymanagementalgorithmtype"}],"output":{"name":"bool"}}],[11,"clone","","",13,{"inputs":[{"name":"self"}],"output":{"name":"keymanagementalgorithmtype"}}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",14,{"inputs":[{"name":"self"},{"name":"contentencryptionalgorithm"}],"output":{"name":"bool"}}],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"contentencryptionalgorithm"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"encryptionresult"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",9,{"inputs":[{"name":"self"},{"name":"encryptionresult"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"self"},{"name":"encryptionresult"}],"output":{"name":"bool"}}],[11,"default","","",9,{"inputs":[],"output":{"name":"encryptionresult"}}],[11,"default","","",11,{"inputs":[],"output":{"name":"self"}}],[11,"default","","",12,{"inputs":[],"output":{"name":"self"}}],[11,"default","","",14,{"inputs":[],"output":{"name":"self"}}],[11,"sign","","Take some bytes and sign it according to the algorithm and secret provided.",11,null],[11,"verify","","Verify signature based on the algorithm and secret provided.",11,null],[11,"algorithm_type","","Returns the type of operations that the algorithm is intended to support",12,{"inputs":[{"name":"self"}],"output":{"name":"keymanagementalgorithmtype"}}],[11,"cek","","Retrieve the Content Encryption Key (CEK) based on the algorithm for encryption",12,{"inputs":[{"name":"self"},{"name":"contentencryptionalgorithm"},{"name":"jwk"}],"output":{"name":"result"}}],[11,"encrypt","","Encrypt or wrap a key with the provided algorithm",12,null],[11,"decrypt","","Decrypt or unwrap a CEK with the provided algorithm",12,{"inputs":[{"name":"self"},{"name":"encryptionresult"},{"name":"contentencryptionalgorithm"},{"name":"jwk"}],"output":{"name":"result"}}],[11,"generate_key","","Convenience function to generate a new random key with the required length",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"encrypt","","Encrypt some payload with the provided algorith",14,null],[11,"decrypt","","Decrypt some payload with the provided algorith,",14,{"inputs":[{"name":"self"},{"name":"encryptionresult"},{"name":"jwk"}],"output":{"name":"result"}}],[0,"jws","biscuit","JSON Web Signatures, including JWT signing and headers",null,null],[3,"Header","biscuit::jws","JWS Header, consisting of the registered fields and other custom fields",null,null],[12,"registered","","Registered header fields",15,null],[12,"private","","Private header fields",15,null],[3,"RegisteredHeader","","Registered JWS header fields. The alg defaults to HS256 and typ is automatically set to `JWT`. All the other fields are optional. The fields are defined by RFC7519#5 and additionally in RFC7515#4.1.",null,null],[12,"algorithm","","Algorithms, as defined in RFC 7518, used to sign or encrypt the JWT Serialized to `alg`. Defined in RFC7515#4.1.1.",16,null],[12,"media_type","","Media type of the complete JWS. Serialized to `typ`. Defined in RFC7519#5.1 and additionally RFC7515#4.1.9. The \"typ\" value \"JOSE\" can be used by applications to indicate that this object is a JWS or JWE using the JWS Compact Serialization or the JWE Compact Serialization.  The \"typ\" value \"JOSE+JSON\" can be used by applications to indicate that this object is a JWS or JWE using the JWS JSON Serialization or the JWE JSON Serialization. Other type values can also be used by applications.",16,null],[12,"content_type","","Content Type of the secured payload. Typically used to indicate the presence of a nested JOSE object which is signed or encrypted. Serialized to `cty`. Defined in RFC7519#5.2 and additionally RFC7515#4.1.10.",16,null],[12,"web_key_url","","The JSON Web Key Set URL. This is currently not implemented (correctly). Serialized to `jku`. Defined in RFC7515#4.1.2.",16,null],[12,"web_key","","The JSON Web Key. This is currently not implemented (correctly). Serialized to `jwk`. Defined in RFC7515#4.1.3.",16,null],[12,"key_id","","The Key ID. This is currently not implemented (correctly). Serialized to `kid`. Defined in RFC7515#4.1.3.",16,null],[12,"x509_url","","X.509 Public key cerfificate URL. This is currently not implemented (correctly). Serialized to `x5u`. Defined in RFC7515#4.1.5.",16,null],[12,"x509_chain","","X.509 public key certificate chain. This is currently not implemented (correctly). Serialized to `x5c`. Defined in RFC7515#4.1.6.",16,null],[12,"x509_fingerprint","","X.509 Certificate thumbprint. This is currently not implemented (correctly). Also not implemented, is the SHA-256 thumbprint variant of this header. Serialized to `x5t`. Defined in RFC7515#4.1.7.",16,null],[12,"critical","","List of critical extended headers. This is currently not implemented (correctly). Serialized to `crit`. Defined in RFC7515#4.1.11.",16,null],[4,"Compact","","Compact representation of a JWS",null,null],[13,"Decoded","","Decoded form of the JWS. This variant cannot be serialized or deserialized and will return an error.",17,null],[12,"header","biscuit::jws::Compact","Embedded header",17,null],[12,"payload","","Payload, usually a claims set",17,null],[13,"Encoded","biscuit::jws","Encoded and (optionally) signed JWT. Use this form to send to your clients",17,null],[4,"Secret","","The secrets used to sign and/or encrypt tokens",null,null],[13,"None","","Used with the `None` algorithm variant.",18,null],[13,"Bytes","","Bytes used for HMAC secret. Can be constructed from a string literal",18,null],[13,"RSAKeyPair","","An RSA Key pair constructed from a DER-encoded private key",18,null],[13,"PublicKey","","Bytes of a DER encoded RSA Public Key",18,null],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"compact"}}],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",17,{"inputs":[{"name":"self"},{"name":"compact"}],"output":{"name":"bool"}}],[11,"ne","","",17,{"inputs":[{"name":"self"},{"name":"compact"}],"output":{"name":"bool"}}],[11,"new_decoded","","New decoded JWT",17,{"inputs":[{"name":"header"},{"name":"t"}],"output":{"name":"self"}}],[11,"new_encoded","","New encoded JWT",17,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"into_encoded","","Consumes self and convert into encoded form. If the token is already encoded, this is a no-op.",17,{"inputs":[{"name":"self"},{"name":"secret"}],"output":{"name":"result"}}],[11,"encode","","Encode the JWT passed and sign the payload using the algorithm from the header and the secret The secret is dependent on the signing algorithm",17,{"inputs":[{"name":"self"},{"name":"secret"}],"output":{"name":"result"}}],[11,"into_decoded","","Consumes self and convert into decoded form, verifying the signature, if any. If the token is already decoded, this is a no-op",17,{"inputs":[{"name":"self"},{"name":"secret"},{"name":"signaturealgorithm"}],"output":{"name":"result"}}],[11,"decode","","Decode a token into the JWT struct and verify its signature If the token or its signature is invalid, it will return an error",17,{"inputs":[{"name":"self"},{"name":"secret"},{"name":"signaturealgorithm"}],"output":{"name":"result"}}],[11,"encoded","","Convenience method to get a reference to the encoded string from an encoded compact JWS",17,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"encoded_mut","","Convenience method to get a mutable reference to the encoded string from an encoded compact JWS",17,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"payload","","Convenience method to get a reference to the claims set from a decoded compact JWS",17,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"payload_mut","","Convenience method to get a reference to the claims set from a decoded compact JWS",17,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"header","","Convenience method to get a reference to the header from a decoded compact JWS",17,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"header_mut","","Convenience method to get a reference to the header from a decoded compact JWS",17,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"unwrap_decoded","","Consumes self, and move the payload and header out and return them as a tuple",17,null],[11,"unwrap_encoded","","Consumes self, and move the encoded Compact out and return it",17,{"inputs":[{"name":"self"}],"output":{"name":"compact"}}],[11,"to_bytes","","",17,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"from_bytes","","",17,null],[11,"bytes_from_str","","Convenience function to create a secret bytes array from a string See example in the [`Secret::Bytes`] variant documentation for usage.",18,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"rsa_keypair_from_file","","Convenience function to get the RSA Keypair from a DER encoded RSA private key. See example in the [`Secret::RSAKeyPair`] variant documentation for usage.",18,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"public_key_from_file","","Convenience function to create a Public key from a DER encoded RSA or ECDSA public key See examples in the [`Secret::PublicKey`] variant documentation for usage.",18,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",15,{"inputs":[{"name":"self"},{"name":"header"}],"output":{"name":"bool"}}],[11,"ne","","",15,{"inputs":[{"name":"self"},{"name":"header"}],"output":{"name":"bool"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"header"}}],[11,"default","","",15,{"inputs":[],"output":{"name":"header"}}],[11,"serialize","","",15,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"deserialize","","",15,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"from_registered_header","","Convenience function to create a header with only registered headers",15,{"inputs":[{"name":"registeredheader"}],"output":{"name":"self"}}],[11,"from","","",15,{"inputs":[{"name":"registeredheader"}],"output":{"name":"self"}}],[11,"clone","","",16,{"inputs":[{"name":"self"}],"output":{"name":"registeredheader"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",16,{"inputs":[{"name":"self"},{"name":"registeredheader"}],"output":{"name":"bool"}}],[11,"ne","","",16,{"inputs":[{"name":"self"},{"name":"registeredheader"}],"output":{"name":"bool"}}],[11,"default","","",16,{"inputs":[],"output":{"name":"registeredheader"}}],[0,"jwk","biscuit","JSON Web Key",null,null],[3,"CommonParameters","biscuit::jwk","Common JWK parameters",null,null],[12,"public_key_use","","The intended use of the public key. Should not be specified with `key_operations`. See sections 4.2 and 4.3 of RFC7517.",19,null],[12,"key_operations","","The \"key_ops\" (key operations) parameter identifies the operation(s) for which the key is intended to be used.  The \"key_ops\" parameter is intended for use cases in which public, private, or symmetric keys may be present. Should not be specified with `public_key_use`. See sections 4.2 and 4.3 of RFC7517.",19,null],[12,"algorithm","","The algorithm intended for use with the key",19,null],[12,"key_id","","The case sensitive Key ID for the key",19,null],[12,"x509_url","","X.509 Public key cerfificate URL. This is currently not implemented (correctly). Serialized to `x5u`.",19,null],[12,"x509_chain","","X.509 public key certificate chain. This is currently not implemented (correctly). Serialized to `x5c`.",19,null],[12,"x509_fingerprint","","X.509 Certificate thumbprint. This is currently not implemented (correctly). Also not implemented, is the SHA-256 thumbprint variant of this header. Serialized to `x5t`.",19,null],[3,"EllipticCurveKeyParameters","","Parameters for an Elliptic Curve Key",null,null],[12,"key_type","","Key type value for an Elliptic Curve Key.",20,null],[12,"curve","","The \"crv\" (curve) parameter identifies the cryptographic curve used with the key.",20,null],[12,"x","","The \"x\" (x coordinate) parameter contains the x coordinate for the Elliptic Curve point. Serialized to base64 URL encoded",20,null],[12,"y","","The \"y\" (y coordinate) parameter contains the y coordinate for the Elliptic Curve point. Serialized to base64 URL encoded",20,null],[12,"d","","The \"d\" (ECC private key) parameter contains the Elliptic Curve private key value.",20,null],[3,"RSAKeyParameters","","Parameters for a RSA Key",null,null],[12,"key_type","","Key type value for a RSA Key",21,null],[12,"n","","The \"n\" (modulus) parameter contains the modulus value for the RSA public key. It is serialized as a `Base64urlUInt`-encoded value.",21,null],[12,"e","","The \"e\" (exponent) parameter contains the exponent value for the RSA public key. It is serialized as a `Base64urlUInt`-encoded value.",21,null],[12,"d","","The \"d\" (private exponent) parameter contains the private exponent value for the RSA private key. It is serialized as a `Base64urlUInt`-encoded value.",21,null],[12,"p","","The \"p\" (first prime factor) parameter contains the first prime factor. It is serialized as a `Base64urlUInt`-encoded value.",21,null],[12,"q","","The \"q\" (second prime factor) parameter contains the second prime factor. It is serialized as a `Base64urlUInt`-encoded value.",21,null],[12,"dp","","The \"dp\" (first factor CRT exponent) parameter contains the Chinese Remainder Theorem (CRT) exponent of the first factor. It is serialized as a `Base64urlUInt`-encoded value.",21,null],[12,"dq","","The \"dq\" (second factor CRT exponent) parameter contains the CRT exponent of the second factor. It is serialized as a `Base64urlUInt`-encoded value.",21,null],[12,"qi","","The \"qi\" (first CRT coefficient) parameter contains the CRT coefficient of the second factor It is serialized as a `Base64urlUInt`-encoded value.",21,null],[12,"other_primes_info","","The \"oth\" (other primes info) parameter contains an array of information about any third and subsequent primes, should they exist.",21,null],[3,"OtherPrimesInfo","","The \"oth\" (other primes info) parameter contains an array of information about any third and subsequent primes, should they exist. When only two primes have been used (the normal case), this parameter MUST be omitted.  When three or more primes have been used, the number of array elements MUST be the number of primes used minus two. For more information on this case, see the description of the `OtherPrimeInfo` parameters in Appendix A.1.2 of RFC 3447, upon which the following parameters are modeled.  If the consumer of a JWK does not support private keys with more than two primes and it encounters a private key that includes the \"oth\" parameter, then it MUST NOT use the key.",null,null],[12,"r","","The \"r\" (prime factor) parameter represents the value of a subsequent prime factor. It is serialized as a Base64urlUInt-encoded value.",22,null],[12,"d","","The \"d\" (factor CRT exponent) parameter represents the CRT exponent of the corresponding prime factor. It is serialized as a Base64urlUInt-encoded value.",22,null],[12,"t","","The \"t\" (factor CRT coefficient) parameter member represents the CRT coefficient of the corresponding prime factor.",22,null],[3,"JWK","","A JSON object that represents a cryptographic key. The members of the object represent properties of the key, including its value. Type `T` is a struct representing additional JWK properties",null,null],[12,"common","","Common JWK parameters",23,null],[12,"algorithm","","Key algorithm specific parameters",23,null],[12,"additional","","Additional JWK parameters",23,null],[3,"JWKSet","","A JSON object that represents a set of JWKs.",null,null],[12,"keys","","Containted JWKs",24,null],[4,"KeyType","","Type of Key as specified in RFC 7518.",null,null],[13,"EllipticCurve","","Elliptic curve keys",25,null],[13,"RSA","","RSA Key",25,null],[13,"Octect","","Octet sequence, representing symmetric keys",25,null],[13,"OctectKeyPair","","Octet string key pairs",25,null],[4,"PublicKeyUse","","The intended usage of the public `KeyType`. This enum is serialized `untagged`",null,null],[13,"Signature","","Indicates a public key is meant for signature verification",26,null],[13,"Encryption","","Indicates a public key is meant for encryption",26,null],[13,"Other","","Other usage",26,null],[4,"KeyOperations","","Operations that the key is intended to be used for. This enum is serialized `untagged`",null,null],[13,"Sign","","Computer digitial signature or MAC",27,null],[13,"Verify","","Verify digital signature or MAC",27,null],[13,"Encrypt","","Encrypt content",27,null],[13,"Decrypt","","Decrypt content and validate decryption, if applicable",27,null],[13,"WrapKey","","Encrypt key",27,null],[13,"UnwrapKey","","Decrypt key and validate decryption, if applicable",27,null],[13,"DeriveKey","","Derive key",27,null],[13,"DeriveBits","","Derive bits not to be used as a key",27,null],[13,"Other","","Other operation",27,null],[4,"AlgorithmParameters","","Algorithm specific parameters",null,null],[13,"EllipticCurve","","An Elliptic Curve key",28,null],[13,"RSA","","A RSA Public or Private Key",28,null],[13,"OctectKey","","A symmetric Octect key",28,null],[12,"key_type","biscuit::jwk::AlgorithmParameters","Key type value for an Octect Key",28,null],[12,"value","","The octect key value",28,null],[4,"EllipticCurveKeyType","biscuit::jwk","Key type value for an Elliptic Curve Key. This single value enum is a workaround for Rust not supporting associated constants.",null,null],[13,"EC","","Key type value for an Elliptic Curve Key.",29,null],[4,"RSAKeyType","","Key type value for an RSA Key. This single value enum is a workaround for Rust not supporting associated constants.",null,null],[13,"RSA","","Key type value for an RSA Key.",30,null],[4,"OctectKeyType","","Key type value for an Octect symmetric Key. This single value enum is a workaround for Rust not supporting associated constants.",null,null],[13,"Octect","","Key type value for an RSA Key.",31,null],[4,"EllipticCurve","","Type of cryptographic curve used by a key. This is defined in RFC 7518 #7.6",null,null],[13,"P256","","P-256 curve",32,null],[13,"P384","","P-384 curve",32,null],[13,"P521","","P-521 curve -- unsupported by `ring`.",32,null],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",25,{"inputs":[{"name":"self"},{"name":"keytype"}],"output":{"name":"bool"}}],[11,"clone","","",25,{"inputs":[{"name":"self"}],"output":{"name":"keytype"}}],[11,"description","","Description of the type of key",25,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",26,{"inputs":[{"name":"self"}],"output":{"name":"publickeyuse"}}],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",26,{"inputs":[{"name":"self"},{"name":"publickeyuse"}],"output":{"name":"bool"}}],[11,"ne","","",26,{"inputs":[{"name":"self"},{"name":"publickeyuse"}],"output":{"name":"bool"}}],[11,"serialize","","",26,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"deserialize","","",26,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"clone","","",27,{"inputs":[{"name":"self"}],"output":{"name":"keyoperations"}}],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",27,{"inputs":[{"name":"self"},{"name":"keyoperations"}],"output":{"name":"bool"}}],[11,"ne","","",27,{"inputs":[{"name":"self"},{"name":"keyoperations"}],"output":{"name":"bool"}}],[11,"serialize","","",27,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"deserialize","","",27,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",19,{"inputs":[{"name":"self"}],"output":{"name":"commonparameters"}}],[11,"eq","","",19,{"inputs":[{"name":"self"},{"name":"commonparameters"}],"output":{"name":"bool"}}],[11,"ne","","",19,{"inputs":[{"name":"self"},{"name":"commonparameters"}],"output":{"name":"bool"}}],[11,"default","","",19,{"inputs":[],"output":{"name":"commonparameters"}}],[11,"clone","","",28,{"inputs":[{"name":"self"}],"output":{"name":"algorithmparameters"}}],[11,"eq","","",28,{"inputs":[{"name":"self"},{"name":"algorithmparameters"}],"output":{"name":"bool"}}],[11,"ne","","",28,{"inputs":[{"name":"self"},{"name":"algorithmparameters"}],"output":{"name":"bool"}}],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"key_type","","Returns the type of key represented by this set of algorithm parameters",28,{"inputs":[{"name":"self"}],"output":{"name":"keytype"}}],[11,"octect_key","","Return the byte sequence of an octect key",28,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"clone","","",20,{"inputs":[{"name":"self"}],"output":{"name":"ellipticcurvekeyparameters"}}],[11,"eq","","",20,{"inputs":[{"name":"self"},{"name":"ellipticcurvekeyparameters"}],"output":{"name":"bool"}}],[11,"ne","","",20,{"inputs":[{"name":"self"},{"name":"ellipticcurvekeyparameters"}],"output":{"name":"bool"}}],[11,"default","","",20,{"inputs":[],"output":{"name":"ellipticcurvekeyparameters"}}],[11,"clone","","",21,{"inputs":[{"name":"self"}],"output":{"name":"rsakeyparameters"}}],[11,"eq","","",21,{"inputs":[{"name":"self"},{"name":"rsakeyparameters"}],"output":{"name":"bool"}}],[11,"ne","","",21,{"inputs":[{"name":"self"},{"name":"rsakeyparameters"}],"output":{"name":"bool"}}],[11,"default","","",21,{"inputs":[],"output":{"name":"rsakeyparameters"}}],[11,"clone","","",22,{"inputs":[{"name":"self"}],"output":{"name":"otherprimesinfo"}}],[11,"eq","","",22,{"inputs":[{"name":"self"},{"name":"otherprimesinfo"}],"output":{"name":"bool"}}],[11,"ne","","",22,{"inputs":[{"name":"self"},{"name":"otherprimesinfo"}],"output":{"name":"bool"}}],[11,"clone","","",29,{"inputs":[{"name":"self"}],"output":{"name":"ellipticcurvekeytype"}}],[11,"fmt","","",29,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",29,{"inputs":[{"name":"self"},{"name":"ellipticcurvekeytype"}],"output":{"name":"bool"}}],[11,"default","","",29,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",30,{"inputs":[{"name":"self"}],"output":{"name":"rsakeytype"}}],[11,"fmt","","",30,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",30,{"inputs":[{"name":"self"},{"name":"rsakeytype"}],"output":{"name":"bool"}}],[11,"default","","",30,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",31,{"inputs":[{"name":"self"}],"output":{"name":"octectkeytype"}}],[11,"fmt","","",31,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",31,{"inputs":[{"name":"self"},{"name":"octectkeytype"}],"output":{"name":"bool"}}],[11,"default","","",31,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",32,{"inputs":[{"name":"self"}],"output":{"name":"ellipticcurve"}}],[11,"fmt","","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",32,{"inputs":[{"name":"self"},{"name":"ellipticcurve"}],"output":{"name":"bool"}}],[11,"default","","",32,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",23,{"inputs":[{"name":"self"}],"output":{"name":"jwk"}}],[11,"fmt","","",23,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",23,{"inputs":[{"name":"self"},{"name":"jwk"}],"output":{"name":"bool"}}],[11,"ne","","",23,{"inputs":[{"name":"self"},{"name":"jwk"}],"output":{"name":"bool"}}],[11,"serialize","","",23,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"deserialize","","",23,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"new_octect_key","","Convenience to create a new bare-bones Octect key",23,null],[11,"clone_without_additional","","Convenience function to strip out the additional fields",23,{"inputs":[{"name":"self"}],"output":{"name":"jwk"}}],[11,"key_type","","Returns the type of key represented by this key",23,{"inputs":[{"name":"self"}],"output":{"name":"keytype"}}],[11,"octect_key","","Return the byte sequence of an octect key",23,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",24,{"inputs":[{"name":"self"},{"name":"jwkset"}],"output":{"name":"bool"}}],[11,"ne","","",24,{"inputs":[{"name":"self"},{"name":"jwkset"}],"output":{"name":"bool"}}],[0,"jwe","biscuit","JSON Web Encryption",null,null],[3,"RegisteredHeader","biscuit::jwe","Registered JWE header fields. The fields are defined by RFC 7516#4.1",null,null],[12,"cek_algorithm","","Algorithm used to encrypt or determine the value of the Content Encryption Key",33,null],[12,"enc_algorithm","","Content encryption algorithm used to perform authenticated encryption on the plaintext to produce the ciphertext and the Authentication Tag",33,null],[12,"compression_algorithm","","Compression algorithm applied to plaintext before encryption, if any. Compression is not supported at the moment. _Must only appear in integrity protected header._",33,null],[12,"media_type","","Media type of the complete JWE. Serialized to `typ`. Defined in RFC7519#5.1 and additionally RFC7515#4.1.9. The \"typ\" value \"JOSE\" can be used by applications to indicate that this object is a JWS or JWE using the JWS Compact Serialization or the JWE Compact Serialization.  The \"typ\" value \"JOSE+JSON\" can be used by applications to indicate that this object is a JWS or JWE using the JWS JSON Serialization or the JWE JSON Serialization. Other type values can also be used by applications.",33,null],[12,"content_type","","Content Type of the secured payload. Typically used to indicate the presence of a nested JOSE object which is signed or encrypted. Serialized to `cty`. Defined in RFC7519#5.2 and additionally RFC7515#4.1.10.",33,null],[12,"web_key_url","","The JSON Web Key Set URL. This is currently not implemented (correctly). Serialized to `jku`. Defined in RFC7515#4.1.2.",33,null],[12,"web_key","","The JSON Web Key. This is currently not implemented (correctly). Serialized to `jwk`. Defined in RFC7515#4.1.3.",33,null],[12,"key_id","","The Key ID. This is currently not implemented (correctly). Serialized to `kid`. Defined in RFC7515#4.1.3.",33,null],[12,"x509_url","","X.509 Public key cerfificate URL. This is currently not implemented (correctly). Serialized to `x5u`. Defined in RFC7515#4.1.5.",33,null],[12,"x509_chain","","X.509 public key certificate chain. This is currently not implemented (correctly). Serialized to `x5c`. Defined in RFC7515#4.1.6.",33,null],[12,"x509_fingerprint","","X.509 Certificate thumbprint. This is currently not implemented (correctly). Also not implemented, is the SHA-256 thumbprint variant of this header. Serialized to `x5t`. Defined in RFC7515#4.1.7.",33,null],[12,"critical","","List of critical extended headers. This is currently not implemented (correctly). Serialized to `crit`. Defined in RFC7515#4.1.11.",33,null],[3,"CekAlgorithmHeader","","Headers specific to the Key management algorithm used. Users should typically not construct these fields as they will be filled in automatically when encrypting and stripped when decrypting",null,null],[12,"nonce","","Header for AES GCM Keywrap algorithm. The initialization vector, or nonce used in the encryption",34,null],[12,"tag","","Header for AES GCM Keywrap algorithm. The authentication tag resulting from the encryption",34,null],[3,"Header","","JWE Header, consisting of the registered fields and other custom fields",null,null],[12,"registered","","Registered header fields",35,null],[12,"cek_algorithm","","Key management algorithm specific headers",35,null],[12,"private","","Private header fields",35,null],[4,"CompressionAlgorithm","","Compression algorithm applied to plaintext before encryption.",null,null],[13,"Deflate","","DEFLATE algorithm defined in RFC 1951",36,null],[13,"Other","","Other user-defined algorithm",36,null],[4,"Compact","","Compact representation of a JWE, or an encrypted JWT",null,null],[13,"Decrypted","","Decrypted form of the JWE. This variant cannot be serialized or deserialized and will return an error.",37,null],[12,"header","biscuit::jwe::Compact","Embedded header",37,null],[12,"payload","","Payload, usually a signed/unsigned JWT",37,null],[13,"Encrypted","biscuit::jwe","Encrypted JWT. Use this form to send to your clients",37,null],[11,"fmt","","",36,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",36,{"inputs":[{"name":"self"},{"name":"compressionalgorithm"}],"output":{"name":"bool"}}],[11,"ne","","",36,{"inputs":[{"name":"self"},{"name":"compressionalgorithm"}],"output":{"name":"bool"}}],[11,"clone","","",36,{"inputs":[{"name":"self"}],"output":{"name":"compressionalgorithm"}}],[11,"serialize","","",36,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"deserialize","","",36,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"clone","","",33,{"inputs":[{"name":"self"}],"output":{"name":"registeredheader"}}],[11,"fmt","","",33,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",33,{"inputs":[{"name":"self"},{"name":"registeredheader"}],"output":{"name":"bool"}}],[11,"ne","","",33,{"inputs":[{"name":"self"},{"name":"registeredheader"}],"output":{"name":"bool"}}],[11,"default","","",33,{"inputs":[],"output":{"name":"registeredheader"}}],[11,"clone","","",34,{"inputs":[{"name":"self"}],"output":{"name":"cekalgorithmheader"}}],[11,"fmt","","",34,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",34,{"inputs":[{"name":"self"},{"name":"cekalgorithmheader"}],"output":{"name":"bool"}}],[11,"ne","","",34,{"inputs":[{"name":"self"},{"name":"cekalgorithmheader"}],"output":{"name":"bool"}}],[11,"default","","",34,{"inputs":[],"output":{"name":"cekalgorithmheader"}}],[11,"fmt","","",35,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",35,{"inputs":[{"name":"self"},{"name":"header"}],"output":{"name":"bool"}}],[11,"ne","","",35,{"inputs":[{"name":"self"},{"name":"header"}],"output":{"name":"bool"}}],[11,"clone","","",35,{"inputs":[{"name":"self"}],"output":{"name":"header"}}],[11,"default","","",35,{"inputs":[],"output":{"name":"header"}}],[11,"serialize","","",35,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"deserialize","","",35,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"from_registered_header","","Convenience function to create a header with only registered headers",35,{"inputs":[{"name":"registeredheader"}],"output":{"name":"self"}}],[11,"from","","",35,{"inputs":[{"name":"registeredheader"}],"output":{"name":"self"}}],[11,"clone","","",37,{"inputs":[{"name":"self"}],"output":{"name":"compact"}}],[11,"fmt","","",37,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",37,{"inputs":[{"name":"self"},{"name":"compact"}],"output":{"name":"bool"}}],[11,"ne","","",37,{"inputs":[{"name":"self"},{"name":"compact"}],"output":{"name":"bool"}}],[11,"new_decrypted","","Create a new encrypted JWE",37,{"inputs":[{"name":"header"},{"name":"t"}],"output":{"name":"self"}}],[11,"new_encrypted","","Create a new encrypted JWE",37,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"into_encrypted","","Consumes self and encrypt it. If the token is already encrypted, this is a no-op.",37,{"inputs":[{"name":"self"},{"name":"jwk"}],"output":{"name":"result"}}],[11,"encrypt","","Encrypt an Decrypted JWE",37,{"inputs":[{"name":"self"},{"name":"jwk"}],"output":{"name":"result"}}],[11,"into_decrypted","","Consumes self and decrypt it. If the token is already decrypted, this is a no-op.",37,{"inputs":[{"name":"self"},{"name":"jwk"},{"name":"keymanagementalgorithm"},{"name":"contentencryptionalgorithm"}],"output":{"name":"result"}}],[11,"decrypt","","Decrypt an encrypted JWE. Provide the expected algorithms to mitigate an attacker modifying the fields",37,{"inputs":[{"name":"self"},{"name":"jwk"},{"name":"keymanagementalgorithm"},{"name":"contentencryptionalgorithm"}],"output":{"name":"result"}}],[11,"encrypted","","Convenience method to get a reference to the encrypted payload",37,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"encrypted_mut","","Convenience method to get a mutable reference to the encrypted payload",37,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"payload","","Convenience method to get a reference to the payload from an Decrypted JWE",37,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"payload_mut","","Convenience method to get a mutable reference to the payload from an Decrypted JWE",37,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"header","","Convenience method to get a reference to the header from an Decrypted JWE",37,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"header_mut","","Convenience method to get a reference to the header from an Decrypted JWE",37,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"unwrap_decrypted","","Consumes self, and move the payload and header out and return them as a tuple",37,null],[11,"unwrap_encrypted","","Consumes self, and move the encrypted Compact serialization out and return it",37,{"inputs":[{"name":"self"}],"output":{"name":"compact"}}],[6,"JWT","biscuit","A convenience type alias of the common \"JWT\" which is a secured/unsecured compact JWS. Type `T` is the type of the private claims, and type `H` is the type of private header fields",null,null],[6,"JWE","","A convenience type alias of a \"JWE\" which is a compact JWE that contains a signed/unsigned compact JWS.",null,null],[8,"CompactPart","","A \"part\" of the compact representation of JWT/JWS/JWE. Parts are first serialized to some form and then base64 encoded and separated by periods.",null,null],[10,"to_bytes","","Convert this part into bytes",38,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[10,"from_bytes","","Convert a sequence of bytes into Self",38,null],[11,"from_base64","","Base64 decode into Self",38,{"inputs":[{"name":"b"}],"output":{"name":"result"}}],[11,"to_base64","","Serialize `Self` to some form and then base64URL Encode",38,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[8,"CompactJson","","A marker trait that indicates that the object is to be serialized to JSON and deserialized from JSON. This is primarily used in conjunction with the `CompactPart` trait which will serialize structs to JSON before base64 encoding, and vice-versa.",null,null],[11,"fmt","","",39,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",39,{"inputs":[{"name":"self"},{"name":"empty"}],"output":{"name":"bool"}}],[11,"clone","","",39,{"inputs":[{"name":"self"}],"output":{"name":"empty"}}],[11,"default","","",39,{"inputs":[],"output":{"name":"empty"}}],[11,"fmt","","",40,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",40,{"inputs":[{"name":"self"},{"name":"base64url"}],"output":{"name":"bool"}}],[11,"ne","","",40,{"inputs":[{"name":"self"},{"name":"base64url"}],"output":{"name":"bool"}}],[11,"clone","","",40,{"inputs":[{"name":"self"}],"output":{"name":"base64url"}}],[11,"unwrap","","Unwrap the embedded string, consuming self in the process",40,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"str","","\"Borrow\" the string",40,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"deref","","",40,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"from_str","","This never fails",40,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"borrow","","",40,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"to_bytes","","",40,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"from_bytes","","Convert a sequence of bytes into Self",40,null],[11,"to_base64","","",40,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"from_base64","","",40,{"inputs":[{"name":"b"}],"output":{"name":"result"}}],[11,"as_ref","","",40,null],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"compact"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"compact"}],"output":{"name":"bool"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"compact"}}],[11,"new","","Create an empty struct",1,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Create an empty struct with some expected capacity",1,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"push","","Push a `CompactPart` to the end",1,{"inputs":[{"name":"self"},{"name":"compactpart"}],"output":{"name":"result"}}],[11,"len","","Returns the number of parts",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns whether there are no parts",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"encode","","Encodes the various parts into Base64 URL encoding and then concatenates them with period '.' This corresponds to the various `Compact` representation in JWE and JWS, for example",1,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"decode","","Convenience function to split an encoded compact representation into a list of `Base64Url`.",1,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"part","","Convenience function to retrieve a part at a certain index and decode into the type desired",1,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"result"}}],[11,"to_string","","Alias of `encode`",1,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"default","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"serialize","","",1,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"deserialize","","",1,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"singleormultiple"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"singleormultiple"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"self"},{"name":"singleormultiple"}],"output":{"name":"bool"}}],[11,"contains","","Checks whether this enum, regardless of single or multiple value contains `value`.",5,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"bool"}}],[11,"iter","","Yields an iterator for the single value or the list",5,{"inputs":[{"name":"self"}],"output":{"name":"box"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"stringoruri"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"stringoruri"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"stringoruri"}],"output":{"name":"bool"}}],[11,"hash","","",6,null],[11,"as_ref","","",6,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"from_str","","Parses a `&str` into a `StringOrUri`. According to RFC 7519, any string containing the \":\" character will be treated as a URL. Any invalid URLs will be treated as failure.",6,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"serialize","","",6,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"deserialize","","",6,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",41,{"inputs":[{"name":"self"}],"output":{"name":"timestamp"}}],[11,"fmt","","",41,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",41,{"inputs":[{"name":"self"},{"name":"timestamp"}],"output":{"name":"bool"}}],[11,"ne","","",41,{"inputs":[{"name":"self"},{"name":"timestamp"}],"output":{"name":"bool"}}],[11,"deref","","",41,null],[11,"from","","",41,{"inputs":[{"name":"datetime"}],"output":{"name":"self"}}],[11,"into","","",41,{"inputs":[{"name":"self"}],"output":{"name":"datetime"}}],[11,"from","","",41,{"inputs":[{"name":"i64"}],"output":{"name":"self"}}],[11,"serialize","","",41,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"deserialize","","",41,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"registeredclaims"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"registeredclaims"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"self"},{"name":"registeredclaims"}],"output":{"name":"bool"}}],[11,"default","","",2,{"inputs":[],"output":{"name":"registeredclaims"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"temporalvalidationoptions"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"self"},{"name":"temporalvalidationoptions"}],"output":{"name":"bool"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"temporalvalidationoptions"}}],[11,"default","","",3,{"inputs":[],"output":{"name":"temporalvalidationoptions"}}],[11,"validate_times","","Validate the temporal claims in the token",2,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"result"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",4,{"inputs":[{"name":"self"},{"name":"claimsset"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"self"},{"name":"claimsset"}],"output":{"name":"bool"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"claimsset"}}],[11,"default","","",4,{"inputs":[],"output":{"name":"claimsset"}}],[11,"serialize","","",4,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"deserialize","","",4,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"parse","","Parse an absolute URL from a string.",42,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"parse_with_params","","Parse an absolute URL from a string and add params to its query string.",42,{"inputs":[{"name":"str"},{"name":"i"}],"output":{"name":"result"}}],[11,"join","","Parse a string as an URL, with this URL as the base URL.",42,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"options","","Return a default `ParseOptions` that can fully configure the URL parser.",42,{"inputs":[],"output":{"name":"parseoptions"}}],[11,"as_str","","Return the serialization of this URL.",42,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"into_string","","Return the serialization of this URL.",42,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"origin","","Return the origin of this URL (https://url.spec.whatwg.org/#origin)",42,{"inputs":[{"name":"self"}],"output":{"name":"origin"}}],[11,"scheme","","Return the scheme of this URL, lower-cased, as an ASCII string without the ':' delimiter.",42,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"has_authority","","Return whether the URL has an 'authority', which can contain a username, password, host, and port number.",42,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"cannot_be_a_base","","Return whether this URL is a cannot-be-a-base URL, meaning that parsing a relative URL string with this URL as the base will return an error.",42,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"username","","Return the username for this URL (typically the empty string) as a percent-encoded ASCII string.",42,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"password","","Return the password for this URL, if any, as a percent-encoded ASCII string.",42,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"has_host","","Equivalent to `url.host().is_some()`.",42,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"host_str","","Return the string representation of the host (domain or IP address) for this URL, if any.",42,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"host","","Return the parsed representation of the host for this URL. Non-ASCII domain labels are punycode-encoded per IDNA.",42,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"domain","","If this URL has a host and it is a domain name (not an IP address), return it.",42,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"port","","Return the port number for this URL, if any.",42,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"port_or_known_default","","Return the port number for this URL, or the default port number if it is known.",42,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"with_default_port","","If the URL has a host, return something that implements `ToSocketAddrs`.",42,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[11,"path","","Return the path for this URL, as a percent-encoded ASCII string. For cannot-be-a-base URLs, this is an arbitrary string that doesn’t start with '/'. For other URLs, this starts with a '/' slash and continues with slash-separated path segments.",42,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"path_segments","","Unless this URL is cannot-be-a-base, return an iterator of '/' slash-separated path segments, each as a percent-encoded ASCII string.",42,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"query","","Return this URL’s query string, if any, as a percent-encoded ASCII string.",42,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"query_pairs","","Parse the URL’s query string, if any, as `application/x-www-form-urlencoded` and return an iterator of (key, value) pairs.",42,{"inputs":[{"name":"self"}],"output":{"name":"parse"}}],[11,"fragment","","Return this URL’s fragment identifier, if any.",42,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"set_fragment","","Change this URL’s fragment identifier.",42,null],[11,"set_query","","Change this URL’s query string.",42,null],[11,"query_pairs_mut","","Manipulate this URL’s query string, viewed as a sequence of name/value pairs in `application/x-www-form-urlencoded` syntax.",42,{"inputs":[{"name":"self"}],"output":{"name":"serializer"}}],[11,"set_path","","Change this URL’s path.",42,null],[11,"path_segments_mut","","Return an object with methods to manipulate this URL’s path segments.",42,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_port","","Change this URL’s port number.",42,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"result"}}],[11,"set_host","","Change this URL’s host.",42,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"result"}}],[11,"set_ip_host","","Change this URL’s host to the given IP address.",42,{"inputs":[{"name":"self"},{"name":"ipaddr"}],"output":{"name":"result"}}],[11,"set_password","","Change this URL’s password.",42,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"result"}}],[11,"set_username","","Change this URL’s username.",42,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"set_scheme","","Change this URL’s scheme.",42,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"from_file_path","","Convert a file name as `std::path::Path` into an URL in the `file` scheme.",42,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"from_directory_path","","Convert a directory name as `std::path::Path` into an URL in the `file` scheme.",42,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"to_file_path","","Assuming the URL is in the `file` scheme or similar, convert its path to an absolute `std::path::Path`.",42,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"description","","",0,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"eq","","",42,{"inputs":[{"name":"self"},{"name":"url"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"parseerror"}],"output":{"name":"bool"}}],[11,"index","","",42,{"inputs":[{"name":"self"},{"name":"rangefull"}],"output":{"name":"str"}}],[11,"index","","",42,{"inputs":[{"name":"self"},{"name":"rangefrom"}],"output":{"name":"str"}}],[11,"index","","",42,{"inputs":[{"name":"self"},{"name":"rangeto"}],"output":{"name":"str"}}],[11,"index","","",42,{"inputs":[{"name":"self"},{"name":"range"}],"output":{"name":"str"}}],[11,"as_ref","","",42,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cmp","","",42,{"inputs":[{"name":"self"},{"name":"url"}],"output":{"name":"ordering"}}],[11,"from","","",0,{"inputs":[{"name":"errors"}],"output":{"name":"parseerror"}}],[11,"from_str","","",42,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"partial_cmp","","",42,{"inputs":[{"name":"self"},{"name":"url"}],"output":{"name":"option"}}],[11,"fmt","","",42,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",42,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"parseerror"}}],[11,"clone","","",42,{"inputs":[{"name":"self"}],"output":{"name":"url"}}],[11,"to_socket_addrs","","",42,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",42,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}]],"paths":[[4,"ParseError"],[3,"Compact"],[3,"RegisteredClaims"],[3,"TemporalValidationOptions"],[3,"ClaimsSet"],[4,"SingleOrMultiple"],[4,"StringOrUri"],[4,"Error"],[4,"ValidationError"],[3,"EncryptionResult"],[4,"Algorithm"],[4,"SignatureAlgorithm"],[4,"KeyManagementAlgorithm"],[4,"KeyManagementAlgorithmType"],[4,"ContentEncryptionAlgorithm"],[3,"Header"],[3,"RegisteredHeader"],[4,"Compact"],[4,"Secret"],[3,"CommonParameters"],[3,"EllipticCurveKeyParameters"],[3,"RSAKeyParameters"],[3,"OtherPrimesInfo"],[3,"JWK"],[3,"JWKSet"],[4,"KeyType"],[4,"PublicKeyUse"],[4,"KeyOperations"],[4,"AlgorithmParameters"],[4,"EllipticCurveKeyType"],[4,"RSAKeyType"],[4,"OctectKeyType"],[4,"EllipticCurve"],[3,"RegisteredHeader"],[3,"CekAlgorithmHeader"],[3,"Header"],[4,"CompressionAlgorithm"],[4,"Compact"],[8,"CompactPart"],[3,"Empty"],[3,"Base64Url"],[3,"Timestamp"],[3,"Url"]]};
initSearch(searchIndex);
